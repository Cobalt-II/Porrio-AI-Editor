<!DOCTYPE html>
<html>
  <head>
    <title>AI Editor</title>
    <style>html,body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        }
     </style>
   </head>
  <body>
    <canvas id="myCanvas" style="border:1px solid #000000;">
    </canvas>
<script>
let canvas = document.getElementById('myCanvas');
var ctx = canvas.getContext("2d");
canvas.height = window.innerHeight;
canvas.width = window.innerWidth;
let players = [];
let enemies = [];
ctx.fillStyle = "green";
ctx.fillRect(0, 0, canvas.width, canvas.height);
/*Type is a name string, health is a health value, fov is a range for the enemy to notice a player at,
xe and ye are the spawn coordinates, speed is well, enemy speed per frame, model is used for dimensions of a 
simple shape model, like a square for instance, and bodydmg is how much health is drained from collision per frame.
*/
class Enemy {
    constructor(type, health, fov, xe, ye, speed, model, bodydmg, maxhealth, rgn) {
        this.type = type;
        this.health = health;
        this.fov = fov;
        this.xe = xe;
        this.ye = ye;
        this.speed = speed;
        this.model = model;
        this.bodydmg = bodydmg;
        this.maxhealth = health;
        this.rgn = rgn;
    }
};
/* Push new AI types with this, if you feel comfortable with an AI you can even put that AI 
into its own seperate class instead of making it dependant on enemy class stats. 
For a quick 2-second example I put together: 
class Smasher {
    constructor(rarity, health, fov, xe, ye, speed, model, bodydmg) {
        this.rarity = rarity;
        this.health = rarity * 100;
        this.fov = fov * (rarity / 2);
        this.xe = xe;
        this.ye = ye;
        this.speed = 1;
        this.model = [5,5];
        this.bodydmg = 1;
    }
};                                                                               
enemies.push(new Smasher(5,100,100,50,50,1,[5,5],1)); here, I made a class for one of my example enemy AI types, 
the Smasher (I also added in a rarity example, so like if you wanted rarer and stronger enemy versions you could),
instead of making a Smasher through the enemy class. Dummy players come after.*/
enemies.push(new Enemy('Smasher', 1000, 100, 100, 200, 0.75, [20, 20], 1, 1000, 0.001));
let walls = [];
// Generate some walls with the Wall class.
class Wall {
    constructor(xw, yw, w, h) {
        this.xw = xw;
        this.yw = yw;
        this.width = w;
        this.height = h;
    }
};
walls.push(new Wall(50, 50, 50, 50));
var Keys = {
    up: false,
    down: false,
    left: false,
    right: false
};
/* Basic weapon system I added. It just rotates a weapon model around the player. If you wish for a different system, 
you can make your own too. Damage is weapon body damage, model is model, rotation is rotation angle, x and y are dummy variables, you can put whatever for them,
rotspeed is the rotational speed, and target is the players[target] that you want to the weapon to apply to. */
let weapons = [];
class Weapon {
    constructor(dmg, model, rotation, x, y, rotspeed, target, health, recharge) {
        this.dmg = dmg;
        this.model = model;
        this.rotation = rotation;
        this.x = x;
        this.y = y;
        this.rotspeed = rotspeed;
        this.target = target;
        this.health = health;
        this.maxhealth = health;
        this.recharge = recharge;
    }
};
/* Added this so you can test enemy targetting on multiple players, these don't move or anything (except for yours), 
they're just a testing default */
class Player {
    constructor(health, x, y, model, bodydmg, maxhealth, rgn) {
        this.health = health;
        this.x = x;
        this.y = y;
        this.model = model;
        this.bodydmg = bodydmg;
        this.maxhealth = health;
        this.rgn = rgn;
    }
};
let x = 0;
let y = 0;
let w = 10;
let h = 10;
let body = 4;
let hp = 100;
let maxhealth = hp;
let rgn = 0.001;
/* game calculates by always pushing your player data first, so that it can refer in its 
calculations to you as players[0] */
players.push(new Player(hp, x, y, [w, h], body, maxhealth, rgn), new Player(100, 75, 75, [10, 10], 4, 100, 0.001), new Player(100, 200, 200, [10, 10], 4, 100, 0.001));

for (let n in players) {
    for (let count = 0; count < 360; count += 45) {
        weapons.push(new Weapon(1, [10, 10], count, 0, 0, 3, n, 75, 75, 1))
    }
};
// Basic rectangular collision function I found on Stack because I was too lazy to make one myself.
function collision(a, b, c, d, aw, cw, bh, dh) {
    let dx = (a + aw / 2) - (c + cw / 2);
    let dy = (b + bh / 2) - (d + dh / 2);
    let width = (aw + cw) / 2;
    let height = (bh + dh) / 2;
    let crossWidth = width * dy;
    let crossHeight = height * dx;
    let collisionn = 'none';
    if (Math.abs(dx) <= width && Math.abs(dy) <= height) {
        if (crossWidth > crossHeight) {
            collisionn = (crossWidth > (-crossHeight)) ? 'bottom' : 'left';
        } else {
            collisionn = (crossWidth > -(crossHeight)) ? 'right' : 'top';
        }
    }
    return (collisionn);
};
// Once again, credits to Stack for letting me be lazy and steal a rotation function that uses the rotation matrix.
function rotate(cx, cy, x, y, angle) {
    var radians = (Math.PI / 180) * angle,
        cos = Math.cos(radians),
        sin = Math.sin(radians),
        nx = (cos * (x - cx)) + (sin * (y - cy)) + cx,
        ny = (cos * (y - cy)) - (sin * (x - cx)) + cy;
    return [nx, ny];
};

function update() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
};

requestAnimationFrame(function draw() {
    if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
        update();
    };
    ctx.fillStyle = "green";
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    if (Keys.up) {
        players[0].y -= 1;
    }

    if (Keys.down) {
        players[0].y += 1;
    }

    if (Keys.left) {
        players[0].x -= 1;
    }

    if (Keys.right) {
        players[0].x += 1;
    }
    if (players[0].x < 0) {
        players[0].x = 0
    };
    if (players[0].x > canvas.width - players[0].model[0]) {
        players[0].x = canvas.width - players[0].model[0]
    };
    if (players[0].y < 0) {
        players[0].y = 0
    };
    if (players[0].y > canvas.height - players[0].model[1]) {
        players[0].y = canvas.height - players[0].model[1]
    };
    for (let count in players) {
        ctx.fillStyle = 'blue';
        if (players[count].health > 0) {
            if (players[count].health < maxhealth) {
                players[count].health += players[count].rgn
            };
            ctx.fillRect(players[count].x, players[count].y, players[count].model[0], players[count].model[1]);
        } else {
            if (count !== 0) {
                players.splice(count, 1)
            }
        }
    };
    for (let coun in weapons) {
        if (players[weapons[coun].target] !== undefined && players[weapons[coun].target].health > 0) {
            let xr = players[weapons[coun].target].x + players[weapons[coun].target].model[0] / 2 - weapons[coun].model[0] / 2;
            let yr = players[weapons[coun].target].y + players[weapons[coun].target].model[1] / 2 - weapons[coun].model[1] / 2;
            weapons[coun].x = xr + players[weapons[coun].target].model[0] / 2 + weapons[coun].model[0] + 5;
            weapons[coun].y = yr + players[weapons[coun].target].model[1] / 2 + weapons[coun].model[1] + 5;
            let r = rotate(xr, yr, weapons[coun].x, weapons[coun].y, weapons[coun].rotation);
            weapons[coun].x = r[0];
            weapons[coun].y = r[1];
            weapons[coun].rotation += weapons[coun].rotspeed;
            if (weapons[coun].rotation >= 360) {
                weapons[coun].rotation = weapons[coun].rotation - 360
            };
            ctx.fillStyle = '#ffe46b';
            if (weapons[coun].health > 0) {
                ctx.fillRect(weapons[coun].x, weapons[coun].y, weapons[coun].model[0], weapons[coun].model[1])
            } else {
                setTimeout(() => {
                    weapons[coun].health = weapons[coun].maxhealth
                }, weapons[coun].recharge * 25)
            }
        } else {
            weapons.splice(coun, 1)
        }
    };
    // Seperate walls from nesting inside of enemies, because then walls will only exist when enemies exist.
    for (let coun in walls) {
        ctx.fillStyle = 'grey';
        ctx.fillRect(walls[coun].xw, walls[coun].yw, walls[coun].width, walls[coun].height);
        for (let n in players) {
            let c = collision(players[n].x, players[n].y, walls[coun].xw, walls[coun].yw, players[n].model[0], walls[coun].width, players[n].model[1], walls[coun].height);
            if (c !== 'none') {
                switch (c) {
                    case 'bottom':
                        players[n].y += walls[coun].yw + walls[coun].height - players[n].y;
                        break;
                    case 'top':
                        players[n].y -= players[n].y + players[n].model[1] - walls[coun].yw;
                        break;
                    case 'left':
                        players[n].x -= players[n].x + players[n].model[0] - walls[coun].xw;;
                        break;
                    case 'right':
                        players[n].x += walls[coun].xw + walls[coun].width - players[n].x;
                        break;
                }
            };
        }
    };
    for (let count in enemies) {
        for (let coun in walls) {
            let d = collision(enemies[count].xe, enemies[count].ye, walls[coun].xw, walls[coun].yw, enemies[count].model[0], walls[coun].width, enemies[count].model[1], walls[coun].height);
            // We don't really need to check for collision type 'none' here, but I still prefer it.
            if (d !== 'none') {
                switch (d) {
                    case 'bottom':
                        enemies[count].ye += walls[coun].yw + walls[coun].height - enemies[count].ye;
                        break;
                    case 'top':
                        enemies[count].ye -= enemies[count].ye + enemies[count].model[1] - walls[coun].yw;
                        break;
                    case 'left':
                        enemies[count].xe -= enemies[count].xe + enemies[count].model[0] - walls[coun].xw;
                        break;
                    case 'right':
                        enemies[count].xe += walls[coun].xw + walls[coun].width - enemies[count].xe;
                        break;
                }
            };
        };
        // Shitty chase function I made
        function chase(x, y, w, h) {
            if (x <= enemies[count].xe && y <= enemies[count].ye) {
                enemies[count].xe -= enemies[count].speed;
                enemies[count].ye -= enemies[count].speed;
            };
            if (x >= enemies[count].xe && y >= enemies[count].ye) {
                enemies[count].ye += enemies[count].speed;
                enemies[count].xe += enemies[count].speed;
            };
            if (x >= enemies[count].xe && y <= enemies[count].ye) {
                enemies[count].ye -= enemies[count].speed;
                enemies[count].xe += enemies[count].speed;
            };
            if (x <= enemies[count].xe && y >= enemies[count].ye) {
                enemies[count].ye += enemies[count].speed;
                enemies[count].xe -= enemies[count].speed;
            };
            if (x >= enemies[count].xe - w && x <= enemies[count].xe + w && y < enemies[count].ye) {
                enemies[count].ye -= enemies[count].speed;
            };
            if (x >= enemies[count].xe - w && x <= enemies[count].xe + w && x > enemies[count].ye) {
                enemies[count].ye += enemies[count].speed;
            };
            if (x > enemies[count].xe && y >= enemies[count].ye - h && y <= enemies[count].ye + h) {
                enemies[count].xe += enemies[count].speed;
            };
            if (x < enemies[count].xe && y >= enemies[count].ye - h && y <= enemies[count].ye + h) {
                enemies[count].xe -= enemies[count].speed;
            }
        };
        if (enemies[count].xe < 0) {
            enemies[count].xe = 0
        };
        if (enemies[count].xe > canvas.width - enemies[count].model[0]) {
            enemies[count].xe = canvas.width - enemies[count].model[0]
        };
        if (enemies[count].ye < 0) {
            enemies[count].ye = 0
        };
        if (enemies[count].ye > canvas.height - enemies[count].model[1]) {
            enemies[count].ye = canvas.height - enemies[count].model[1]
        };
        if (enemies[count].health > 0) {
            if (enemies[count].health < enemies[count].maxhealth) {
                enemies[count].health += enemies[count].rgn
            };
            for (let coun in weapons) {
                if (weapons[coun].health > 0) {
                    if (collision(weapons[coun].x, weapons[coun].y, enemies[count].xe, enemies[count].ye, weapons[coun].model[0], enemies[count].model[0], weapons[coun].model[1], enemies[count].model[1]) !== 'none') {
                        enemies[count].health -= weapons[coun].dmg;
                        weapons[coun].health -= enemies[count].bdydmg;
                    }
                }
            };
            // Push in new enemy AI algorithms and designs here
            switch (enemies[count].type) {
                case 'Smasher':
                    ctx.fillStyle = 'red';
                    ctx.fillRect(enemies[count].xe, enemies[count].ye, enemies[count].model[0], enemies[count].model[1]);
                    let targets = [];
                    for (let coun in players) {
                        if (collision(players[coun].x, players[coun].y, enemies[count].xe, enemies[count].ye, players[coun].model[0], enemies[count].model[0], players[coun].model[1], enemies[count].model[1]) !== 'none') {
                            players[coun].health -= enemies[count].bodydmg;
                            enemies[count].health -= players[coun].bodydmg;
                        };
                        if (Math.hypot(players[coun].x - enemies[count].xe, players[coun].y - enemies[count].ye) < enemies[count].fov) {
                            targets.push([
                                [players[coun].x, players[coun].y, players[coun].model[0], players[coun].model[1]], Math.hypot(players[coun].x - enemies[count].xe, players[coun].y - enemies[count].ye)
                            ]);
                        }
                    };
                    if (targets.length) {
                        let targ = targets.reduce((dist, dist2) => dist[1] < dist2[1] ? dist[0] : dist2[0]);
                        if (targ.length === 2) {
                            chase(targ[0][0], targ[0][1], targ[0][2], targ[0][3])
                        }
                        if (targ.length === 4) {
                            chase(targ[0], targ[1], targ[2], targ[3])
                        }
                    };
                    break;
            }
        } else {
            enemies.splice(count, 1)
        }; // Deletes dead enemies
    };
    // If you die it just automatically resets you. 
    if (players[0].health < 1) {
        players[0].health = 100;
        players[0].x = 0;
        players[0].y = 0;
    };
    requestAnimationFrame(draw);
});
document.onkeydown = function(e) {
    e.preventDefault();
    switch (e.code) {
        case 'KeyA':
            Keys.left = true;
            break;
        case 'KeyW':
            Keys.up = true;
            break;
        case 'KeyD':
            Keys.right = true;
            break;
        case 'KeyS':
            Keys.down = true;
            break;
    }
};

document.onkeyup = function(e) {
    e.preventDefault();
    switch (e.code) {
        case 'KeyA':
            Keys.left = false;
            break;
        case 'KeyW':
            Keys.up = false;
            break;
        case 'KeyD':
            Keys.right = false;
            break;
        case 'KeyS':
            Keys.down = false;
            break;
    }
};
</script>
  </body>
</html>
